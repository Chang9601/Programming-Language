배열을 선언하는 방법은 2 가지가 있는데 하나는 C/C++와 같고 다른 하나는 다음과 같다.
자료형[] 배열 이름 = new 자료형[개수](e.g. int[] A = new int[5])

배열을 선언과 동시에 특정 값으로 초기화 하지 않아도 자료형에 따라 정수 0,실수 0.0,객체 배열은 null로 초기화된다. 하지만 특정 값으로 초기화할 때 주의할 점이 있는데 []안에 개수를 쓰면 오류가 발생한다. 또한 선언과 동시에 초기화할 때 new 자료형[] 생략 가능(하지만 먼저 선언하고 초기화하는 경우 생략 불가능)

배열을 순회할 때 배열 길이를 나타내는 length를 사용할 수 있다.(이 length의 특징은 처음에 선언된 배열의 전체 요소 개수를 의미한다. 만약 전체 요소 개수가 10이고 모두 0인데 앞의 4개 정도만 값을 설정했을 경우 length를 사용하면 안 된다.)

객체 배열의 경우 기본 자료형의 배열과 다르다. 객체 배열의 경우 인스턴스를 생성하면 그 인스턴스를 가리키는 주소 값이 있다.(여기서 포인터 배열이 생각났다.) 예를 들어 Student[] school = new Student[100]은 각각의 Student 인스턴스 주소 값을 담을 공간 100개를 생성한다. 이는 Student 주소 값을 담을 공간이 100개 만들어지고 자동으로 null(비어 있음)로 초기화 되어있다. 따라서 각 배열 요소마다 인스턴스를 반드시 생성해야 한다.

배열 복사 시 System.arraycopy(src,srcPos,dest,destPos,length) 메서드를 사용할 수 있다. 각 매개변수의 의미는 다음과 같다.(대상 배열의 크기는 원본과 같거나 커야한다.)
src:원본 배열 이름
srcPos:원본 배열의 첫 번째 위치
dest:대상 배열 이름 
destPos:대상 배열에 붙여 넣기를 시작할 첫 번째 위치
length:원본에서 대상으로 자료를 복사할 요소 개수

이 메서드는 객체를 복사할 경우 얕은 복사를 수행하는데 그 이유는 객체 배열의 요소가 인스턴스 자체가 아니고 인스턴스의 주소 값이라서 arraycopy를 사용하면 기존 인스턴스의 주소 값만 복사한다. 따라서 배열의 각 요소가 서로 다른 인스턴스를 가리키게 하려면 깊은 복사를 수행 해야한다. 깊은 복사는 직접 인스턴스를 만들고 그 값을 복사한다.

자바 5부터 제공되는 향상된 for문은 배열의 처음부터 끝까지 순회할 때 사용된다.(C++의 for와 같다.)

2차원 배열의 선언은 다음과 같다. 자료형[][] 배열 이름 = new 자료형[행][열]. 만약 int[2][3] A라는 배열이 있으면 행의 길이는 A.length,열의 길이는 A[0].length

자바에서 C++의 vector와 같이 기존 배열이 가지는 단점을 보완하는 ArrayList라는 객체 배열 클래스가 있다. 다음과 같이 선언을 한다. ArrayList<E> 배열 이름 = new ArrayList<E>();

나 혼자 코딩, 연습 문제에 딱히 어려운 문제가 없었다. 공부를 하면서 다음과 같은 질문이 떠올랐는데 "왜 자바에는 C++처럼 클래스 객체를 그냥 스택에 생성할 수 없을까" 아마 가상 머신 때문일까? 검색을 해보니 단순성(simplicity) 때문이라고 나온다. 자바는 힙 기반 객체를 필수적으로 지원하지만 스택 기반 객체는 최적화를 할 때 발생하고 이는 내부적으로 이루어져서 사용자가 제어할 수 있는 부분이 아니다.(https://stackoverflow.com/questions/31371650/why-java-doesnt-allow-object-on-stack)
